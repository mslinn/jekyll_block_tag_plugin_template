#!/usr/bin/env ruby

# frozen_string_literal: true

require "fileutils"

# Install os if not already installed
begin
  gem "os"
rescue Gem::LoadError
  Gem.install("tty-prompt")
  gem "tty-prompt"
end
require "os"

# Install tty-prompt if not already installed
begin
  gem "tty-prompt"
rescue Gem::LoadError
  Gem.install("tty-prompt")
  gem "tty-prompt"
end
require "tty-prompt"

# Install git if not already installed
begin
  gem "git"
rescue Gem::LoadError
  Gem.install("git")
  gem "git"
end
require "git"

class ScriptHelper
  def initialize
    @prompt = TTY::Prompt.new
  end

  def ask(prompt, default_value = nil)
    if default_value
      @prompt.ask(prompt, :value => default_value)
    else
      @prompt.ask(prompt)
    end
  end

  def edit_contents(filename, edits)
    contents = File.read(filename).gsub(%r!\w!, edits)
    File.write(filename, contents)
  end

  def run(command)
    `#{command}`.chomp
  end

  def to_camel_case(string)
    string.split("_").collect(&:capitalize).join
  end

end

class RunThisFirst < ScriptHelper
  def initialize
    super
    @old_name = "jekyll_block_tag_plugin_template"
  end

  def create_repo
    unless run("which gh")
      puts "gh is not installed, so you will have to push the new git repo to the hosting service of your choice"
      exit
    end
    unless run("gh auth status").include? "Logged in to github.com"
      puts "gh is not logged in, so you will have to push the new git repo to the hosting service of your choice"
    end
    if @prompt.yes?("Create a GitHub project for this new git repository?")
      visibility = @prompt.select("Public or private?", %w(public private))
      `gh repo create #{@git_repo_name} --#{visibility}` # See https://cli.github.com/manual/gh_repo_create
      puts "A #{visibility} git repository called #{git_repo_name} has been created."
    end
  end

  def delete_run_this_first
    ["bin/setup", "README.md"].each do |filename|
      modified = File.readlines(filename).reject { |f| %r!run_this_first!.match(f) }
      File.write(filename, modified.join)
    end
  end

  def doit
    Dir.chdir `git rev-parse --show-toplevel`.chomp

    @new_name = obtain_new_name
    rename_directories(@old_name, @new_name)
    rename_files(@old_name, @new_name)
    rename_variables(@old_name, @new_name)

    @copyright_holder = obtain_copyright_holder
    edit_license

    delete_run_this_first

    `git remote rename origin upstream`

    @git_user_name = obtain_git_user_name
    edit_readme

    @git_user_name = obtain_git_user_name
    create_repo @git_user_name
  end

  def edit_license
    edits = {
      "2022"            => Date.today.year.to_s,
      "COPYRIGHT_OWNER" => get_copyright_holder,
    }
    edit_contents(edits, "LICENSE.txt")
  end

  def edit_readme
    edits = { "git_user_name" => @git_user_name }
    edit_contents(edits, "README.md")
  end

  def obtain_copyright_holder
    done = false
    answer = ""
    loop do
      answer = ask("Please specify the name of the copyright holder for this Jekyll plugin:")
      if answer.nil?
        puts "You must specify a name. Please try again."
      else
        done = true
      end
      break if done
    end
    answer
  end

  def obtain_git_repo_name
    # do
    #   read -e -p "What do you want to call the new git repository for this gem? " -i "$GIT_REPO_NAME" GIT_REPO_NAME
    #   if [[ -z "$GIT_REPO_NAME" ]]; then
    #     echo "If you do not want to specify a git repo name, press Control-C, or try again."
    #     unset GIT_REPO_NAME
    #   fi

    #   if [[ "$( has_spaces $GIT_REPO_NAME )" ]]; then
    #     echo "The git repo name must not contain spaces. Please try again."
    #     unset GIT_REPO_NAME
    #   fi
    # while [[ -z "$GIT_REPO_NAME" ]]
    # echo "$GIT_REPO_NAME"
  end

  def obtain_git_user_name
    # loop do
    #   puts "What is your git user name? #{git_user_name}"
    #   git_user_name = STDIN.gets.chomp.strip
    #   if [[ -z "$GIT_USER_NAME" ]]; then
    #     echo "You must specify a git user name. Please try again."
    #     unset GIT_USER_NAME
    #   fi

    #   if [[ "$( has_spaces $NEW_NAME )" ]]; then
    #     echo "The name must not contain spaces. Please try again."
    #     unset NEW_NAME
    #   fi
    # break if git_user_name
    # end
    # echo "$GIT_USER_NAME"
  end

  def obtain_new_name(new_name)
    done = false
    answer = ""
    loop do
      answer = ask("Please specify the name of this plugin in snake_case:", new_name)
      if answer.nil?
        puts "You must specify a name. Please try again."
      elsif answer.include?(" ")
        puts "The name must not contain spaces. Please try again."
      else
        done = true
      end
      break if done
    end
    answer
  end

  def help
    puts <<~END_HELP
      Rename the Jekyll template, including directories and files.
    END_HELP
    exit
  end

  def rename_directories(old_name, new_name)
    Dir["**/*"]
      .select { |x| x.is_directory? && x.include?(old_name) }
      .each do |directory|
        new_name = directory.gsub(old_name, new_name)
        FileUtils.mv directory, new_name
      end
  end

  def rename_files(old_name, new_name)
    Dir["**/#{old_name}.*"]
      .select(&:is_file?)
      .each do |file|
        filetype = File.basename(file, ".*")
        FileUtils.mv(file, "#{new_name}.#{filetype}")
      end
  end

  def rename_variables(old_name, new_name)
    camel_case_old = to_camel_case(old_name)
    camel_case_new = to_camel_case(new_name)
    Dir["**/*.*"]
      .select(&:is_file?)
      .each do |filename|
        edits = {
          old_name       => new_name,
          camel_case_old => camel_case_new,
        }
        edit_contents(filename, edits)
      end
  end

  def verify_logged_in
    if run("which gh").empty?
      puts <<~MSG
        This project needs to be pushed to a new git repo at a hosting service like GitHub.
        The gh cli would need to be installed if you want this script to create a repo for you on GitHub.
      MSG
      if @prompt.yes?("Do you want to install the gh cli before continuing?")
        puts "Be sure to run 'gh auth' to log in before rerunning this script."
        system(OS.open_file_command, "https://cli.github.com/")
        exit
      end
    end
    run("gh auth login") unless run("gh auth status 2>&1").include?("Logged in to")
  end
end

run_this_first = RunThisFirst.new
# puts run_this_first.obtain_copyright_holder
# puts run_this_first.obtain_new_name("old_name")
run_this_first.verify_logged_in
# run_this_first.doit
